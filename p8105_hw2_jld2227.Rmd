---
title: "HW2 p8105 James Dalgleish jld2227"
author: "James Dalgleish"
date: "September 27, 2018"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
```
#### Problem 1
Instructions(I'm choosing to include these to make it a bit easier to grade):
"Read and clean the data; retain line, station, name, station latitude / 
longitude, routes served, entry, vending, entrance type, and ADA compliance.
Convert the entry variable from character (YES vs NO) to a logical variable
(the ifelse or recode function may be useful)."
```{r data_import}
subway_data = read_csv("./problem1/NYC_Transit_Subway_Entrance_And_Exit_Data.csv") %>%
  janitor::clean_names() %>% 
  select(c("line","station_name","station_latitude","station_longitude",
           starts_with("route"),"entry","vending","ada")) %>% 
  mutate(entry = recode(entry,"YES" = TRUE, "NO" = FALSE))
subway_data 
```
###### Data description
Instruction: "Write a short paragraph about this dataset â€“ 
explain briefly what variables the dataset contains, 
describe your data cleaning steps so far,
and give the dimension (rows x columns) of the resulting dataset.
Are these data tidy?"

Essentially, the dataset contains two character variables dening the subway line and station,
two numeric (double) variables denoting geolocation (latitude and longitude),
11 variables denoting the routes (mostly populated with missing values) in a wide format,
two logical TRUE/FALSE variables for entry and ada,
and a character variable with values "YES" and "NO" variable for vending.
The data is not tidy for at least the reasons that routes are in a wide format 
where the route is encoded in the column. This can be remedied with the 
gather function. As we'll see below, route1 was been encoded in
mixed case(see the "E" and "e"?),
which may mess up some downstream analysis as well.

The dataset contains `r nrow(subway_data)` rows and `r ncol(subway_data)`
columns. Data cleaning included reading the data into a tibble, 
selecting the necessary columns, converting the column names 
into a standard format, and converting the entry variable into a logical column.
```{r describe}
skimr::skim( subway_data )
#sapply(subway_data, table)
subway_data %>% 
  select(starts_with( "route" )) %>%
  sapply(., table)
```
 Putting the wide format into long could aid analysis and can be done with a simple gather command. We'll also get rid of names that appear to be the same, but differ only on case. There are stations with FS and GS lines, but
which might seem like more than one line in a single obserrvation, but they are distinct lines if one looks an MTA licensed site:
https://moveonmap.com/nyc/lnG_GS_FS/
If they were F and S incorrectly noted in the same row, we could consider using separate_rows() to fix that.
We'll use the table function to show that we've now fixed the lower and upper case e.
```{r wide_to_long}
subway_data_long = subway_data %>% 
  gather(key = "route_number", value = "train", route1:route11) %>% 
  mutate(train = tolower(train))
subway_data_long
subway_data_long %>% 
  pull( train ) %>% 
  table( )
```
####### Distinct stations
Instruction: "Answer the following questions using these data:

How many distinct stations are there? Note that stations are identified both by name and by line (e.g. 125th St A/B/C/D; 125st 1; 125st 4/5); the distinct function may be useful here.
How many stations are ADA compliant?
What proportion of station entrances / exits without vending allow entrance?"

We'll now select the columns of interest and limit to only the distinct rows,
then count the number of distinct rows containing route number and train
combinations.
```{r distinct_stations}
subway_routes_trains <- subway_data_long %>%
  select("route_number", "train") %>%
  distinct() %>% 
  na.omit() %>% 
  arrange(route_number,train)
subway_routes_trains
nrow(subway_routes_trains)
```
There happen to be `r nrow(subway_routes_trains)` distinct stations, according to the data.

####### Ada compliance
We will create an additional variable denoting if the station ada is compliant. There can be multiple entrances, only some of which are ada compliant. As a simple rule, a station is compliant if there is at least one station name/line combination with an ada compliant entrance, then it is ada compliant. 
```{r n_ada_compliant_stations}
ada_accessible_stations <- subway_data_long %>%
  select("route_number","train","ada") %>% 
  filter( ada == TRUE) %>%
  distinct(route_number,train, .keep_all = TRUE) %>% 
  na.omit %>% 
  arrange(route_number,train)
ada_accessible_stations
```

####### Station entrances/exists that without vending which allow entry.
Instruction: "What proportion of station entrances /
exits without vending allow entrance?"
The original form "contains information related to each entrance and exit for
each subway station in NYC."
So, we will use this format to answer a question about entrances.
Careful verification through subsetting for duplicate locations reveals that 
this is the case.
Even looking at the latitude and longitude of the entrance does not distinctly 
identify the station.
In some cases, there is a different kind of entrance (elevator/escalator) or
the station is located on a different
corner of an intersection.
Converting wide to long as before could mislead someone to thinking that
there are more entrances than exist in cases where the entrance services 
multiple routes.
Therefore, the way to solve this problem is simple...
read the original data in with minimal processing, filter on the vending and
entry criteria, then count the number of rows. Using the distinct function
can prove again, that the rows are distinct.
```{r ent_exit_wo_vending}
subway_ent_exit_locations = read_csv("./problem1/NYC_Transit_Subway_Entrance_And_Exit_Data.csv") %>%
  janitor::clean_names()# %>% 
  #select(c("entrance_location"))
subway_ent_exit_locations %>% 
  distinct()  %>% 
  nrow()
subway_ent_exit_locations %>% 
  nrow()
  #mutate(entry = recode(entry,"YES" = TRUE, "NO" = FALSE))
# subway_ent_exit_locations[duplicated(subway_ent_exit_locations$entrance_location),] %>% arrange()
# subway_ent_exit_locations[duplicated(subway_ent_exit_locations$entrance_location),] %>% arrange(entrance_location)
# subway_ent_exit_locations %>% filter(entrance_location %in% unlist(subway_ent_exit_locations[duplicated(subway_ent_exit_locations$entrance_location),"entrance_location"])) %>% 
#   arrange() %>% slice(7:11)
# subway_ent_exit_locations %>% filter(entrance_location %in% unlist(subway_ent_exit_locations[duplicated(subway_ent_exit_locations$entrance_location),"entrance_location"])) %>% 
#   arrange() %>% slice(5:6)
duplicated_locations<-subway_ent_exit_locations %>% filter(duplicated(entrance_location)) %>% 
  pull(entrance_location)
duplicated_locations_subset<-subway_ent_exit_locations %>% 
  filter(entrance_location %in% duplicated_locations) %>% 
  arrange()

enterable_novend <- subway_ent_exit_locations %>% 
  filter(.,vending == "NO" & entry == "YES") 
enterable_novend %>% 
  nrow()
enterable_novend %>% 
  distinct() %>% 
  nrow()
```

The number of distinct enterable subway entrances/exits without vending is
therefore `r enterable_novend %>% distinct() %>% nrow()`.

Instruction: "Reformat data so that route number and route name are distinct variables. 
How many distinct stations serve the A train? How many are ADA compliant?"

First we'll tackle the number of distinct A train stations. We've done most of the work by using gather() earlier.
The problem description's route name I have chosen to call train
(the value argument in gather).
I will change the name to make this clearer for the reader.
```{r distinct_a_stations}
subway_data_long_a = subway_data %>% 
  gather(key = "route_number",value = "route_name",route1:route11) %>% 
  mutate(line = tolower(line))   %>% 
  filter(route_name == "A") %>% 
  distinct(station_name,line) %>%
  arrange(station_name,line)
subway_data_long_a
```

It becomes clear now that there are precicsely `r nrow(subway_data_long_a)`
stations that service the A train.

Finally, how many are ada compliant follows a nearly identical process using the 
filter function.
```{r n_ada_stations}
subway_data_long_ada = subway_data %>% 
  gather(key = "route_number",value = "route_name",route1:route11) %>% 
  filter(ada == TRUE) %>% 
  mutate(line = tolower(line))   %>% 
  distinct(station_name,line) %>%
  arrange(station_name,line)
subway_data_long_ada
```

It becomes clear now that there are precicsely `r nrow(subway_data_long_ada)`
stations where there is an accessible entrance. Assuming one entrance is
sufficent for compliance per station, then this represents the number of
accessible stations.

#### Problem 2
instruction: "Read and clean the Mr. Trash Wheel sheet:

*specify the sheet in the Excel file and to omit columns containing notes (using the range argument and cell_cols() function)
*use reasonable variable names
*omit rows that do not include dumpster-specific data
*rounds the number of sports balls to the nearest integer and converts the result to an integer variable (using as.integer)"